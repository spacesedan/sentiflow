// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: batch.go

package db

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const createHeadlinesBatch = `-- name: CreateHeadlinesBatch :batchexec
INSERT INTO headlines (
    id, query, category, sentiment_score,
    meta_source, meta_title, meta_author, meta_description,
    meta_published_at, meta_url, meta_url_to_image
)
SELECT
    p_id, p_query, p_category, p_sentiment_score,
    p_meta_source, p_meta_title, p_meta_author, p_meta_description,
    p_meta_published_at, p_meta_url, p_meta_url_to_image
FROM UNNEST(
    $1::text[],
    $2::text[],
    $3::text[],
    $4::real[],
    $5::text[],
    $6::text[],
    $7::text[],
    $8::text[],
    $9::timestamptz[],
    $10::text[],
    $11::text[]
) AS t(p_id, p_query, p_category, p_sentiment_score, p_meta_source, p_meta_title, p_meta_author, p_meta_description, p_meta_published_at, p_meta_url, p_meta_url_to_image)
`

type CreateHeadlinesBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateHeadlinesBatchParams struct {
	Ids              []string             `json:"ids"`
	Queries          []string             `json:"queries"`
	Categories       []string             `json:"categories"`
	SentimentScores  []float32            `json:"sentiment_scores"`
	MetaSources      []string             `json:"meta_sources"`
	MetaTitles       []string             `json:"meta_titles"`
	MetaAuthors      []string             `json:"meta_authors"`
	MetaDescriptions []string             `json:"meta_descriptions"`
	MetaPublishedAts []pgtype.Timestamptz `json:"meta_published_ats"`
	MetaUrls         []string             `json:"meta_urls"`
	MetaUrlToImages  []string             `json:"meta_url_to_images"`
}

// Inserts multiple headlines in a single query using UNNEST.
// The order of parameters in the UNNEST function must match the order of columns in the INSERT statement.
func (q *Queries) CreateHeadlinesBatch(ctx context.Context, arg []CreateHeadlinesBatchParams) *CreateHeadlinesBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Ids,
			a.Queries,
			a.Categories,
			a.SentimentScores,
			a.MetaSources,
			a.MetaTitles,
			a.MetaAuthors,
			a.MetaDescriptions,
			a.MetaPublishedAts,
			a.MetaUrls,
			a.MetaUrlToImages,
		}
		batch.Queue(createHeadlinesBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateHeadlinesBatchBatchResults{br, len(arg), false}
}

func (b *CreateHeadlinesBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateHeadlinesBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createSentimentResultsBatch = `-- name: CreateSentimentResultsBatch :batchexec
INSERT INTO sentiment_results (
    content_id, headline_id, headline_query, headline_category,
    source, raw_content_topic, text_analyzed, was_summarized, original_text,
    metadata_timestamp, metadata_author, metadata_subreddit, metadata_post_id, metadata_url,
    sentiment_score, sentiment_label, confidence
)
SELECT
    p_content_id, p_headline_id, p_headline_query, p_headline_category,
    p_source, p_raw_content_topic, p_text_analyzed, p_was_summarized, p_original_text,
    p_metadata_timestamp, p_metadata_author, p_metadata_subreddit, p_metadata_post_id, p_metadata_url,
    p_sentiment_score, p_sentiment_label, p_confidence
FROM UNNEST(
    $1::text[],
    $2::text[],
    $3::text[],
    $4::text[],
    $5::text[],
    $6::text[],
    $7::text[],
    $8::boolean[],
    $9::text[],
    $10::timestamptz[],
    $11::text[],
    $12::text[],
    $13::text[],
    $14::text[],
    $15::double precision[],
    $16::text[],
    $17::double precision[]
) AS t(p_content_id, p_headline_id, p_headline_query, p_headline_category, p_source, p_raw_content_topic, p_text_analyzed, p_was_summarized, p_original_text, p_metadata_timestamp, p_metadata_author, p_metadata_subreddit, p_metadata_post_id, p_metadata_url, p_sentiment_score, p_sentiment_label, p_confidence)
`

type CreateSentimentResultsBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateSentimentResultsBatchParams struct {
	ContentIds         []string             `json:"content_ids"`
	HeadlineIds        []string             `json:"headline_ids"`
	HeadlineQueries    []string             `json:"headline_queries"`
	HeadlineCategories []string             `json:"headline_categories"`
	Sources            []string             `json:"sources"`
	RawContentTopics   []string             `json:"raw_content_topics"`
	TextsAnalyzed      []string             `json:"texts_analyzed"`
	WereSummarized     []bool               `json:"were_summarized"`
	OriginalTexts      []string             `json:"original_texts"`
	MetadataTimestamps []pgtype.Timestamptz `json:"metadata_timestamps"`
	MetadataAuthors    []string             `json:"metadata_authors"`
	MetadataSubreddits []string             `json:"metadata_subreddits"`
	MetadataPostIds    []string             `json:"metadata_post_ids"`
	MetadataUrls       []string             `json:"metadata_urls"`
	SentimentScores    []float64            `json:"sentiment_scores"`
	SentimentLabels    []string             `json:"sentiment_labels"`
	Confidences        []float64            `json:"confidences"`
}

// Inserts multiple sentiment results in a single query using UNNEST.
func (q *Queries) CreateSentimentResultsBatch(ctx context.Context, arg []CreateSentimentResultsBatchParams) *CreateSentimentResultsBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ContentIds,
			a.HeadlineIds,
			a.HeadlineQueries,
			a.HeadlineCategories,
			a.Sources,
			a.RawContentTopics,
			a.TextsAnalyzed,
			a.WereSummarized,
			a.OriginalTexts,
			a.MetadataTimestamps,
			a.MetadataAuthors,
			a.MetadataSubreddits,
			a.MetadataPostIds,
			a.MetadataUrls,
			a.SentimentScores,
			a.SentimentLabels,
			a.Confidences,
		}
		batch.Queue(createSentimentResultsBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateSentimentResultsBatchBatchResults{br, len(arg), false}
}

func (b *CreateSentimentResultsBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateSentimentResultsBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
