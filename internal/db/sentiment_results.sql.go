// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sentiment_results.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSentimentResult = `-- name: CreateSentimentResult :one
INSERT INTO sentiment_results (
    content_id, headline_id, headline_query, headline_category,
    source, raw_content_topic, text_analyzed, was_summarized, original_text,
    metadata_timestamp, metadata_author, metadata_subreddit, metadata_post_id, metadata_url,
    sentiment_score, sentiment_label, confidence
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
)
RETURNING content_id, headline_id, headline_query, headline_category, source, raw_content_topic, text_analyzed, was_summarized, original_text, metadata_timestamp, metadata_author, metadata_subreddit, metadata_post_id, metadata_url, sentiment_score, sentiment_label, confidence, created_at, updated_at
`

type CreateSentimentResultParams struct {
	ContentID         string             `json:"content_id"`
	HeadlineID        pgtype.Text        `json:"headline_id"`
	HeadlineQuery     pgtype.Text        `json:"headline_query"`
	HeadlineCategory  pgtype.Text        `json:"headline_category"`
	Source            pgtype.Text        `json:"source"`
	RawContentTopic   pgtype.Text        `json:"raw_content_topic"`
	TextAnalyzed      pgtype.Text        `json:"text_analyzed"`
	WasSummarized     pgtype.Bool        `json:"was_summarized"`
	OriginalText      pgtype.Text        `json:"original_text"`
	MetadataTimestamp pgtype.Timestamptz `json:"metadata_timestamp"`
	MetadataAuthor    pgtype.Text        `json:"metadata_author"`
	MetadataSubreddit pgtype.Text        `json:"metadata_subreddit"`
	MetadataPostID    pgtype.Text        `json:"metadata_post_id"`
	MetadataUrl       pgtype.Text        `json:"metadata_url"`
	SentimentScore    pgtype.Float8      `json:"sentiment_score"`
	SentimentLabel    pgtype.Text        `json:"sentiment_label"`
	Confidence        pgtype.Float8      `json:"confidence"`
}

func (q *Queries) CreateSentimentResult(ctx context.Context, arg CreateSentimentResultParams) (SentimentResult, error) {
	row := q.db.QueryRow(ctx, createSentimentResult,
		arg.ContentID,
		arg.HeadlineID,
		arg.HeadlineQuery,
		arg.HeadlineCategory,
		arg.Source,
		arg.RawContentTopic,
		arg.TextAnalyzed,
		arg.WasSummarized,
		arg.OriginalText,
		arg.MetadataTimestamp,
		arg.MetadataAuthor,
		arg.MetadataSubreddit,
		arg.MetadataPostID,
		arg.MetadataUrl,
		arg.SentimentScore,
		arg.SentimentLabel,
		arg.Confidence,
	)
	var i SentimentResult
	err := row.Scan(
		&i.ContentID,
		&i.HeadlineID,
		&i.HeadlineQuery,
		&i.HeadlineCategory,
		&i.Source,
		&i.RawContentTopic,
		&i.TextAnalyzed,
		&i.WasSummarized,
		&i.OriginalText,
		&i.MetadataTimestamp,
		&i.MetadataAuthor,
		&i.MetadataSubreddit,
		&i.MetadataPostID,
		&i.MetadataUrl,
		&i.SentimentScore,
		&i.SentimentLabel,
		&i.Confidence,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSentimentResult = `-- name: DeleteSentimentResult :exec
DELETE FROM sentiment_results
WHERE content_id = $1
`

func (q *Queries) DeleteSentimentResult(ctx context.Context, contentID string) error {
	_, err := q.db.Exec(ctx, deleteSentimentResult, contentID)
	return err
}

const getSentimentResult = `-- name: GetSentimentResult :one
SELECT content_id, headline_id, headline_query, headline_category, source, raw_content_topic, text_analyzed, was_summarized, original_text, metadata_timestamp, metadata_author, metadata_subreddit, metadata_post_id, metadata_url, sentiment_score, sentiment_label, confidence, created_at, updated_at FROM sentiment_results
WHERE content_id = $1 LIMIT 1
`

func (q *Queries) GetSentimentResult(ctx context.Context, contentID string) (SentimentResult, error) {
	row := q.db.QueryRow(ctx, getSentimentResult, contentID)
	var i SentimentResult
	err := row.Scan(
		&i.ContentID,
		&i.HeadlineID,
		&i.HeadlineQuery,
		&i.HeadlineCategory,
		&i.Source,
		&i.RawContentTopic,
		&i.TextAnalyzed,
		&i.WasSummarized,
		&i.OriginalText,
		&i.MetadataTimestamp,
		&i.MetadataAuthor,
		&i.MetadataSubreddit,
		&i.MetadataPostID,
		&i.MetadataUrl,
		&i.SentimentScore,
		&i.SentimentLabel,
		&i.Confidence,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSentimentResultsByHeadline = `-- name: ListSentimentResultsByHeadline :many
SELECT content_id, headline_id, headline_query, headline_category, source, raw_content_topic, text_analyzed, was_summarized, original_text, metadata_timestamp, metadata_author, metadata_subreddit, metadata_post_id, metadata_url, sentiment_score, sentiment_label, confidence, created_at, updated_at FROM sentiment_results
WHERE headline_id = $1
ORDER BY created_at DESC
LIMIT $3
OFFSET $2
`

type ListSentimentResultsByHeadlineParams struct {
	HeadlineID pgtype.Text `json:"headline_id"`
	ItemOffset int64       `json:"item_offset"`
	ItemLimit  int64       `json:"item_limit"`
}

func (q *Queries) ListSentimentResultsByHeadline(ctx context.Context, arg ListSentimentResultsByHeadlineParams) ([]SentimentResult, error) {
	rows, err := q.db.Query(ctx, listSentimentResultsByHeadline, arg.HeadlineID, arg.ItemOffset, arg.ItemLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SentimentResult{}
	for rows.Next() {
		var i SentimentResult
		if err := rows.Scan(
			&i.ContentID,
			&i.HeadlineID,
			&i.HeadlineQuery,
			&i.HeadlineCategory,
			&i.Source,
			&i.RawContentTopic,
			&i.TextAnalyzed,
			&i.WasSummarized,
			&i.OriginalText,
			&i.MetadataTimestamp,
			&i.MetadataAuthor,
			&i.MetadataSubreddit,
			&i.MetadataPostID,
			&i.MetadataUrl,
			&i.SentimentScore,
			&i.SentimentLabel,
			&i.Confidence,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSentimentResultsBySource = `-- name: ListSentimentResultsBySource :many
SELECT content_id, headline_id, headline_query, headline_category, source, raw_content_topic, text_analyzed, was_summarized, original_text, metadata_timestamp, metadata_author, metadata_subreddit, metadata_post_id, metadata_url, sentiment_score, sentiment_label, confidence, created_at, updated_at FROM sentiment_results
WHERE source = $1
ORDER BY created_at DESC
LIMIT $3
OFFSET $2
`

type ListSentimentResultsBySourceParams struct {
	Source     pgtype.Text `json:"source"`
	ItemOffset int64       `json:"item_offset"`
	ItemLimit  int64       `json:"item_limit"`
}

// Example read query: lists results by their raw content source
func (q *Queries) ListSentimentResultsBySource(ctx context.Context, arg ListSentimentResultsBySourceParams) ([]SentimentResult, error) {
	rows, err := q.db.Query(ctx, listSentimentResultsBySource, arg.Source, arg.ItemOffset, arg.ItemLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SentimentResult{}
	for rows.Next() {
		var i SentimentResult
		if err := rows.Scan(
			&i.ContentID,
			&i.HeadlineID,
			&i.HeadlineQuery,
			&i.HeadlineCategory,
			&i.Source,
			&i.RawContentTopic,
			&i.TextAnalyzed,
			&i.WasSummarized,
			&i.OriginalText,
			&i.MetadataTimestamp,
			&i.MetadataAuthor,
			&i.MetadataSubreddit,
			&i.MetadataPostID,
			&i.MetadataUrl,
			&i.SentimentScore,
			&i.SentimentLabel,
			&i.Confidence,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
