// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: headlines.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createHeadline = `-- name: CreateHeadline :one
INSERT INTO headlines (
    id, query, category, sentiment_score,
    meta_source, meta_title, meta_author, meta_description,
    meta_published_at, meta_url, meta_url_to_image
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING id, query, category, sentiment_score, meta_source, meta_title, meta_author, meta_description, meta_published_at, meta_url, meta_url_to_image, created_at, updated_at
`

type CreateHeadlineParams struct {
	ID              string             `json:"id"`
	Query           pgtype.Text        `json:"query"`
	Category        pgtype.Text        `json:"category"`
	SentimentScore  pgtype.Float4      `json:"sentiment_score"`
	MetaSource      pgtype.Text        `json:"meta_source"`
	MetaTitle       pgtype.Text        `json:"meta_title"`
	MetaAuthor      pgtype.Text        `json:"meta_author"`
	MetaDescription pgtype.Text        `json:"meta_description"`
	MetaPublishedAt pgtype.Timestamptz `json:"meta_published_at"`
	MetaUrl         pgtype.Text        `json:"meta_url"`
	MetaUrlToImage  pgtype.Text        `json:"meta_url_to_image"`
}

func (q *Queries) CreateHeadline(ctx context.Context, arg CreateHeadlineParams) (Headline, error) {
	row := q.db.QueryRow(ctx, createHeadline,
		arg.ID,
		arg.Query,
		arg.Category,
		arg.SentimentScore,
		arg.MetaSource,
		arg.MetaTitle,
		arg.MetaAuthor,
		arg.MetaDescription,
		arg.MetaPublishedAt,
		arg.MetaUrl,
		arg.MetaUrlToImage,
	)
	var i Headline
	err := row.Scan(
		&i.ID,
		&i.Query,
		&i.Category,
		&i.SentimentScore,
		&i.MetaSource,
		&i.MetaTitle,
		&i.MetaAuthor,
		&i.MetaDescription,
		&i.MetaPublishedAt,
		&i.MetaUrl,
		&i.MetaUrlToImage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteHeadline = `-- name: DeleteHeadline :exec
DELETE FROM headlines
WHERE id = $1
`

func (q *Queries) DeleteHeadline(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteHeadline, id)
	return err
}

const getHeadline = `-- name: GetHeadline :one
SELECT id, query, category, sentiment_score, meta_source, meta_title, meta_author, meta_description, meta_published_at, meta_url, meta_url_to_image, created_at, updated_at FROM headlines
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetHeadline(ctx context.Context, id string) (Headline, error) {
	row := q.db.QueryRow(ctx, getHeadline, id)
	var i Headline
	err := row.Scan(
		&i.ID,
		&i.Query,
		&i.Category,
		&i.SentimentScore,
		&i.MetaSource,
		&i.MetaTitle,
		&i.MetaAuthor,
		&i.MetaDescription,
		&i.MetaPublishedAt,
		&i.MetaUrl,
		&i.MetaUrlToImage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listHeadlines = `-- name: ListHeadlines :many
SELECT id, query, category, sentiment_score, meta_source, meta_title, meta_author, meta_description, meta_published_at, meta_url, meta_url_to_image, created_at, updated_at FROM headlines
ORDER BY created_at DESC
LIMIT $2
OFFSET $1
`

type ListHeadlinesParams struct {
	ItemOffset int64 `json:"item_offset"`
	ItemLimit  int64 `json:"item_limit"`
}

func (q *Queries) ListHeadlines(ctx context.Context, arg ListHeadlinesParams) ([]Headline, error) {
	rows, err := q.db.Query(ctx, listHeadlines, arg.ItemOffset, arg.ItemLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Headline{}
	for rows.Next() {
		var i Headline
		if err := rows.Scan(
			&i.ID,
			&i.Query,
			&i.Category,
			&i.SentimentScore,
			&i.MetaSource,
			&i.MetaTitle,
			&i.MetaAuthor,
			&i.MetaDescription,
			&i.MetaPublishedAt,
			&i.MetaUrl,
			&i.MetaUrlToImage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHeadlineSentiment = `-- name: UpdateHeadlineSentiment :one
UPDATE headlines
SET sentiment_score = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, query, category, sentiment_score, meta_source, meta_title, meta_author, meta_description, meta_published_at, meta_url, meta_url_to_image, created_at, updated_at
`

type UpdateHeadlineSentimentParams struct {
	ID             string        `json:"id"`
	SentimentScore pgtype.Float4 `json:"sentiment_score"`
}

func (q *Queries) UpdateHeadlineSentiment(ctx context.Context, arg UpdateHeadlineSentimentParams) (Headline, error) {
	row := q.db.QueryRow(ctx, updateHeadlineSentiment, arg.ID, arg.SentimentScore)
	var i Headline
	err := row.Scan(
		&i.ID,
		&i.Query,
		&i.Category,
		&i.SentimentScore,
		&i.MetaSource,
		&i.MetaTitle,
		&i.MetaAuthor,
		&i.MetaDescription,
		&i.MetaPublishedAt,
		&i.MetaUrl,
		&i.MetaUrlToImage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
